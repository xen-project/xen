diff -uprN tpm_emulator-0.3/crypto/gmp_kernel_wrapper.c tpm_emulator-0.3-x86_64/crypto/gmp_kernel_wrapper.c
--- tpm_emulator-0.3/crypto/gmp_kernel_wrapper.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/crypto/gmp_kernel_wrapper.c	2006-05-26 11:26:02.000000000 -0700
@@ -79,7 +79,7 @@ void __attribute__ ((regparm(0))) *kerne
 {
   void *ret  = (void*)kmalloc(size, GFP_KERNEL);
   if (!ret) panic(KERN_CRIT TPM_MODULE_NAME 
-    "GMP: cannot allocate memory (size=%u)\n", size);
+    "GMP: cannot allocate memory (size=%Zu)\n", size);
   return ret;
 }
 
@@ -88,7 +88,7 @@ void __attribute__ ((regparm(0))) *kerne
 {
   void *ret = (void*)kmalloc(new_size, GFP_KERNEL);
   if (!ret) panic(KERN_CRIT TPM_MODULE_NAME "GMP: Cannot reallocate memory "
-    "(old_size=%u new_size=%u)\n", old_size, new_size);
+    "(old_size=%Zu new_size=%Zu)\n", old_size, new_size);
   memcpy(ret, oldptr, old_size);
   kfree(oldptr);
   return ret;
diff -uprN tpm_emulator-0.3/linux_module.c tpm_emulator-0.3-x86_64/linux_module.c
--- tpm_emulator-0.3/linux_module.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/linux_module.c	2006-05-26 11:26:02.000000000 -0700
@@ -72,7 +72,7 @@ static int tpm_release(struct inode *ino
 
 static ssize_t tpm_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
-  debug("%s(%d)", __FUNCTION__, count);
+  debug("%s(%Zu)", __FUNCTION__, count);
   down(&tpm_mutex);
   if (tpm_response.data != NULL) {
     count = min(count, (size_t)tpm_response.size - (size_t)*ppos);
@@ -91,7 +91,7 @@ static ssize_t tpm_read(struct file *fil
 
 static ssize_t tpm_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
 {
-  debug("%s(%d)", __FUNCTION__, count);
+  debug("%s(%Zu)", __FUNCTION__, count);
   down(&tpm_mutex);
   *ppos = 0;
   if (tpm_response.data != NULL) kfree(tpm_response.data);
diff -uprN tpm_emulator-0.3/linux_module.h tpm_emulator-0.3-x86_64/linux_module.h
--- tpm_emulator-0.3/linux_module.h	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/linux_module.h	2006-05-26 11:26:02.000000000 -0700
@@ -28,8 +28,10 @@
 
 /* module settings */
 
+#ifndef STR
 #define STR(s) __STR__(s)
 #define __STR__(s) #s
+#endif
 #include "tpm_version.h"
 
 #define TPM_DEVICE_MINOR	224
diff -uprN tpm_emulator-0.3/Makefile tpm_emulator-0.3-x86_64/Makefile
--- tpm_emulator-0.3/Makefile	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/Makefile	2006-05-26 11:26:02.000000000 -0700
@@ -7,6 +7,7 @@
 KERNEL_RELEASE := $(shell uname -r)
 KERNEL_BUILD   := /lib/modules/$(KERNEL_RELEASE)/build
 MOD_SUBDIR     := misc
+COMPILE_ARCH    ?= $(shell uname -m | sed -e s/i.86/x86_32/)
 
 # module settings
 MODULE_NAME    := tpm_emulator
@@ -17,8 +18,14 @@ VERSION_BUILD  := $(shell date +"%s")
 # enable/disable DEBUG messages
 EXTRA_CFLAGS   += -Wall -DDEBUG -g  
 
+ifeq ($(COMPILE_ARCH),x86_64)
+LIBDIR = lib64
+else
+LIBDIR = lib
+endif
+
 # GNU MP configuration
-GMP_LIB        := /usr/lib/libgmp.a
+GMP_LIB        := /usr/$(LIBDIR)/libgmp.a
 GMP_HEADER     := /usr/include/gmp.h
 
 # sources and objects
diff -uprN tpm_emulator-0.3/README tpm_emulator-0.3-x86_64/README
--- tpm_emulator-0.3/README	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/README	2006-05-26 11:26:02.000000000 -0700
@@ -43,6 +43,12 @@ Example:
 GMP_LIB        := /usr/lib/libgmp.a
 GMP_HEADER     := /usr/include/gmp.h
 
+GNU MP Library on 64 bit Systems
+--------------------------------------------------------------------------
+Some 64-bit kernels have problems with importing the user-space gmp 
+library (/usr/lib*/libgmp.a) into kernel space.  These kernels will require
+that the gmp library be recompiled for kernel space with -mcmodel=kernel.
+
 Installation
 --------------------------------------------------------------------------
 The compilation and installation process uses the build environment for 
diff -uprN tpm_emulator-0.3/tpm/tpm_credentials.c tpm_emulator-0.3-x86_64/tpm/tpm_credentials.c
--- tpm_emulator-0.3/tpm/tpm_credentials.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_credentials.c	2006-05-26 11:26:02.000000000 -0700
@@ -47,16 +47,16 @@ int tpm_compute_pubkey_checksum(TPM_NONC
 
 TPM_RESULT tpm_get_pubek(TPM_PUBKEY *pubEndorsementKey)
 {
-  UINT32 key_length;
+  size_t key_length;
   if (!tpmData.permanent.data.endorsementKey.size) return TPM_NO_ENDORSEMENT;
   /* setup TPM_PUBKEY structure */
-  key_length = tpmData.permanent.data.endorsementKey.size;
-  pubEndorsementKey->pubKey.keyLength = key_length >> 3;
+  pubEndorsementKey->pubKey.keyLength = tpmData.permanent.data.endorsementKey.size >> 3;
   pubEndorsementKey->pubKey.key = tpm_malloc(pubEndorsementKey->pubKey.keyLength);
   if (pubEndorsementKey->pubKey.key == NULL) return TPM_FAIL;
   rsa_export_modulus(&tpmData.permanent.data.endorsementKey,
-    pubEndorsementKey->pubKey.key,
-    &pubEndorsementKey->pubKey.keyLength);
+		     pubEndorsementKey->pubKey.key,
+		     &key_length);
+  pubEndorsementKey->pubKey.keyLength = key_length;
   pubEndorsementKey->algorithmParms.algorithmID = TPM_ALG_RSA;
   pubEndorsementKey->algorithmParms.encScheme = TPM_ES_RSAESOAEP_SHA1_MGF1;
   pubEndorsementKey->algorithmParms.sigScheme = TPM_SS_NONE;
@@ -175,6 +175,7 @@ TPM_RESULT TPM_OwnerReadInternalPub(TPM_
 {
   TPM_RESULT res;
   TPM_KEY_DATA *srk = &tpmData.permanent.data.srk;
+  size_t key_length;
   info("TPM_OwnerReadInternalPub()");
   /* verify authorization */
   res = tpm_verify_auth(auth1, tpmData.permanent.data.ownerAuth, TPM_KH_OWNER);
@@ -186,7 +187,8 @@ TPM_RESULT TPM_OwnerReadInternalPub(TPM_
     publicPortion->pubKey.key = tpm_malloc(publicPortion->pubKey.keyLength);
     if (publicPortion->pubKey.key == NULL) return TPM_FAIL;
     rsa_export_modulus(&srk->key, publicPortion->pubKey.key, 
-      &publicPortion->pubKey.keyLength);
+      &key_length);
+    publicPortion->pubKey.keyLength = key_length;
     publicPortion->algorithmParms.algorithmID = TPM_ALG_RSA;
     publicPortion->algorithmParms.encScheme = srk->encScheme;
     publicPortion->algorithmParms.sigScheme = srk->sigScheme;
diff -uprN tpm_emulator-0.3/tpm/tpm_crypto.c tpm_emulator-0.3-x86_64/tpm/tpm_crypto.c
--- tpm_emulator-0.3/tpm/tpm_crypto.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_crypto.c	2006-05-26 11:26:02.000000000 -0700
@@ -182,7 +182,8 @@ TPM_RESULT TPM_CertifyKey(TPM_KEY_HANDLE
   TPM_KEY_DATA *cert, *key;
   sha1_ctx_t sha1_ctx;
   BYTE *buf, *p;
-  UINT32 length;
+  UINT32 length32;
+  size_t length;
   info("TPM_CertifyKey()");
   /* get keys */
   cert = tpm_get_key(certHandle);
@@ -264,14 +265,15 @@ TPM_RESULT TPM_CertifyKey(TPM_KEY_HANDLE
   /* compute the digest of the CERTIFY_INFO[2] structure and sign it */
   length = sizeof_TPM_CERTIFY_INFO((*certifyInfo));
   p = buf = tpm_malloc(length);
+  length32=(UINT32) length;
   if (buf == NULL
-      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length, certifyInfo)) {
+      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length32, certifyInfo)) {
     free_TPM_KEY_PARMS(certifyInfo->algorithmParms);
     return TPM_FAIL;
   }
   length = sizeof_TPM_CERTIFY_INFO((*certifyInfo));
   sha1_init(&sha1_ctx);
-  sha1_update(&sha1_ctx, buf, length);
+  sha1_update(&sha1_ctx, buf, (size_t) length);
   sha1_final(&sha1_ctx, buf);
   res = tpm_sign(cert, auth1, FALSE, buf, SHA1_DIGEST_LENGTH, outData, outDataSize);
   tpm_free(buf);
@@ -292,7 +294,8 @@ TPM_RESULT TPM_CertifyKey2(TPM_KEY_HANDL
   TPM_KEY_DATA *cert, *key;
   sha1_ctx_t sha1_ctx;
   BYTE *buf, *p;
-  UINT32 length;
+  size_t length;
+  UINT32 length32;
   info("TPM_CertifyKey2()");
   /* get keys */
   cert = tpm_get_key(certHandle);
@@ -362,8 +365,9 @@ TPM_RESULT TPM_CertifyKey2(TPM_KEY_HANDL
   /* compute the digest of the CERTIFY_INFO[2] structure and sign it */
   length = sizeof_TPM_CERTIFY_INFO((*certifyInfo));
   p = buf = tpm_malloc(length);
+  length32 = (UINT32) length;
   if (buf == NULL
-      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length, certifyInfo)) {
+      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length32, certifyInfo)) {
     free_TPM_KEY_PARMS(certifyInfo->algorithmParms);
     return TPM_FAIL;
   }
diff -uprN tpm_emulator-0.3/tpm/tpm_data.c tpm_emulator-0.3-x86_64/tpm/tpm_data.c
--- tpm_emulator-0.3/tpm/tpm_data.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_data.c	2006-05-26 11:26:02.000000000 -0700
@@ -214,7 +214,7 @@ static int read_from_file(uint8_t **data
 int tpm_store_permanent_data(void)
 {
   uint8_t *buf, *ptr;
-  size_t buf_length, len;
+  UINT32 buf_length, len;
 
   /* marshal data */
   buf_length = len = sizeof_TPM_STCLEAR_FLAGS(tpmData.stclear.flags)
@@ -242,13 +242,14 @@ int tpm_store_permanent_data(void)
 int tpm_restore_permanent_data(void)
 {
   uint8_t *buf, *ptr;
-  size_t buf_length, len;
+  size_t buf_length;
+  UINT32 len;
   TPM_VERSION ver;
 
   /* read data */
   if (read_from_file(&buf, &buf_length)) return -1;
   ptr = buf;
-  len = buf_length;
+  len = (uint32_t) buf_length;
   /* unmarshal data */
   if (tpm_unmarshal_TPM_VERSION(&ptr, &len, &ver)
       || memcmp(&ver, &tpmData.permanent.data.version, sizeof(TPM_VERSION))
diff -uprN tpm_emulator-0.3/tpm/tpm_marshalling.c tpm_emulator-0.3-x86_64/tpm/tpm_marshalling.c
--- tpm_emulator-0.3/tpm/tpm_marshalling.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_marshalling.c	2006-05-26 11:26:02.000000000 -0700
@@ -1212,7 +1212,7 @@ int tpm_unmarshal_TPM_STANY_FLAGS(BYTE *
 
 int tpm_marshal_RSA(BYTE **ptr, UINT32 *length, rsa_private_key_t *v)
 {
-  UINT32 m_len, e_len, q_len;
+  size_t m_len, e_len, q_len;
   if (*length < sizeof_RSA((*v))) return -1;
   if (v->size > 0) {
     rsa_export_modulus(v, &(*ptr)[6], &m_len);
diff -uprN tpm_emulator-0.3/tpm/tpm_owner.c tpm_emulator-0.3-x86_64/tpm/tpm_owner.c
--- tpm_emulator-0.3/tpm/tpm_owner.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_owner.c	2006-05-26 11:26:02.000000000 -0700
@@ -108,7 +108,7 @@ TPM_RESULT TPM_TakeOwnership(TPM_PROTOCO
   TPM_RESULT res;
   rsa_private_key_t *ek = &tpmData.permanent.data.endorsementKey;
   TPM_KEY_DATA *srk = &tpmData.permanent.data.srk;
-  UINT32 buf_size = ek->size >> 3;
+  size_t buf_size = ek->size >> 3, key_length; 
   BYTE buf[buf_size];
 
   info("TPM_TakeOwnership()");
@@ -172,7 +172,8 @@ TPM_RESULT TPM_TakeOwnership(TPM_PROTOCO
     return TPM_FAIL;
   }
   rsa_export_modulus(&srk->key, srkPub->pubKey.key,
-    &srkPub->pubKey.keyLength);
+		     &key_length);
+  srkPub->pubKey.keyLength = (UINT32) key_length;
   /* setup tpmProof and set state to owned */
   tpm_get_random_bytes(tpmData.permanent.data.tpmProof.nonce, 
     sizeof(tpmData.permanent.data.tpmProof.nonce));
diff -uprN tpm_emulator-0.3/tpm/tpm_storage.c tpm_emulator-0.3-x86_64/tpm/tpm_storage.c
--- tpm_emulator-0.3/tpm/tpm_storage.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_storage.c	2006-05-26 14:33:18.000000000 -0700
@@ -58,6 +58,7 @@ int encrypt_sealed_data(TPM_KEY_DATA *ke
                         BYTE *enc, UINT32 *enc_size)
 {
   UINT32 len;
+  size_t enc_size32 = *enc_size;
   BYTE *buf, *ptr;
   rsa_public_key_t pub_key;
   int scheme;
@@ -72,7 +73,7 @@ int encrypt_sealed_data(TPM_KEY_DATA *ke
   if (buf == NULL
       || tpm_marshal_TPM_SEALED_DATA(&ptr, &len, seal)
       || rsa_encrypt(&pub_key, scheme, buf, sizeof_TPM_SEALED_DATA((*seal)),
-                     enc, enc_size)) {
+                     enc, &enc_size32)) {
     tpm_free(buf);
     rsa_release_public_key(&pub_key);
     return -1;
@@ -85,7 +86,8 @@ int encrypt_sealed_data(TPM_KEY_DATA *ke
 int decrypt_sealed_data(TPM_KEY_DATA *key, BYTE *enc, UINT32 enc_size,
                         TPM_SEALED_DATA *seal, BYTE **buf) 
 {
-  UINT32 len;
+  size_t len;
+  UINT32 len32;
   BYTE *ptr;
   int scheme;
   switch (key->encScheme) {
@@ -96,8 +98,12 @@ int decrypt_sealed_data(TPM_KEY_DATA *ke
   len = enc_size;
   *buf = ptr = tpm_malloc(len);
   if (*buf == NULL
-      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len)
-      || tpm_unmarshal_TPM_SEALED_DATA(&ptr, &len, seal)) {
+      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len) ){
+    tpm_free(*buf);
+    return -1;
+  }
+  len32 = len;
+  if (tpm_unmarshal_TPM_SEALED_DATA(&ptr, &len32, seal)) {
     tpm_free(*buf);
     return -1;
   }
@@ -237,11 +243,12 @@ TPM_RESULT TPM_Unseal(TPM_KEY_HANDLE par
 
 TPM_RESULT TPM_UnBind(TPM_KEY_HANDLE keyHandle, UINT32 inDataSize,
                       BYTE *inData, TPM_AUTH *auth1, 
-                      UINT32 *outDataSize, BYTE **outData)
+                      UINT32 *outDataSize32, BYTE **outData)
 {
   TPM_RESULT res;
   TPM_KEY_DATA *key;
   int scheme;
+  size_t outDataSize;
   info("TPM_UnBind()");
   /* get key */
   key = tpm_get_key(keyHandle);
@@ -258,8 +265,8 @@ TPM_RESULT TPM_UnBind(TPM_KEY_HANDLE key
   /* the size of the input data muss be greater than zero */
   if (inDataSize == 0) return TPM_BAD_PARAMETER;
   /* decrypt data */
-  *outDataSize = inDataSize;
-  *outData = tpm_malloc(*outDataSize);
+  outDataSize = inDataSize;
+  *outData = tpm_malloc(outDataSize);
   if (*outData == NULL) return TPM_FAIL;
   switch (key->encScheme) {
     case TPM_ES_RSAESOAEP_SHA1_MGF1: scheme = RSA_ES_OAEP_SHA1; break;
@@ -267,20 +274,21 @@ TPM_RESULT TPM_UnBind(TPM_KEY_HANDLE key
     default: tpm_free(*outData); return TPM_DECRYPT_ERROR;
   }
   if (rsa_decrypt(&key->key, scheme, inData, inDataSize, 
-      *outData, outDataSize)) {
+      *outData, &outDataSize)) {
     tpm_free(*outData);
     return TPM_DECRYPT_ERROR;
   }
   /* verify data if it is of type TPM_BOUND_DATA */
   if (key->encScheme == TPM_ES_RSAESOAEP_SHA1_MGF1 
       || key->keyUsage != TPM_KEY_LEGACY) {
-    if (*outDataSize < 5 || memcmp(*outData, "\x01\x01\00\x00\x02", 5) != 0) {
+    if (outDataSize < 5 || memcmp(*outData, "\x01\x01\00\x00\x02", 5) != 0) {
       tpm_free(*outData);
       return TPM_DECRYPT_ERROR;
     }
-    *outDataSize -= 5;
-    memmove(*outData, &(*outData)[5], *outDataSize);
+    outDataSize -= 5;
+    memmove(*outData, &(*outData)[5], outDataSize);
   }
+  *outDataSize32 = (UINT32) outDataSize;
   return TPM_SUCCESS;
 }
 
@@ -311,12 +319,13 @@ static int verify_key_digest(TPM_KEY *ke
 }
 
 int encrypt_private_key(TPM_KEY_DATA *key, TPM_STORE_ASYMKEY *store,
-                        BYTE *enc, UINT32 *enc_size)
+                        BYTE *enc, UINT32 *enc_size32)
 {
   UINT32 len;
   BYTE *buf, *ptr;
   rsa_public_key_t pub_key;
   int scheme;
+  size_t enc_size;
   switch (key->encScheme) {
     case TPM_ES_RSAESOAEP_SHA1_MGF1: scheme = RSA_ES_OAEP_SHA1; break;
     case TPM_ES_RSAESPKCSv15: scheme = RSA_ES_PKCSV15; break;
@@ -328,11 +337,12 @@ int encrypt_private_key(TPM_KEY_DATA *ke
   if (buf == NULL
       || tpm_marshal_TPM_STORE_ASYMKEY(&ptr, &len, store)
       || rsa_encrypt(&pub_key, scheme, buf, sizeof_TPM_STORE_ASYMKEY((*store)),
-                     enc, enc_size)) {
+                     enc, &enc_size)) {
     tpm_free(buf);
     rsa_release_public_key(&pub_key);
     return -1;
   }
+  *enc_size32 = (UINT32) enc_size;
   tpm_free(buf);
   rsa_release_public_key(&pub_key);
   return 0;
@@ -341,7 +351,8 @@ int encrypt_private_key(TPM_KEY_DATA *ke
 int decrypt_private_key(TPM_KEY_DATA *key, BYTE *enc, UINT32 enc_size, 
                         TPM_STORE_ASYMKEY *store, BYTE **buf) 
 {
-  UINT32 len;
+  UINT32 len32;
+  size_t len;
   BYTE *ptr;
   int scheme;
   switch (key->encScheme) {
@@ -352,8 +363,12 @@ int decrypt_private_key(TPM_KEY_DATA *ke
   len = enc_size;
   *buf = ptr = tpm_malloc(len);
   if (*buf == NULL
-      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len)
-      || tpm_unmarshal_TPM_STORE_ASYMKEY(&ptr, &len, store)) {
+      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len) ) {
+    tpm_free(*buf);
+    return -1;
+  }
+  len32 = (UINT32) len;
+  if (tpm_unmarshal_TPM_STORE_ASYMKEY(&ptr, &len32, store)) {  
     tpm_free(*buf);
     return -1;
   }
@@ -371,7 +386,7 @@ TPM_RESULT TPM_CreateWrapKey(TPM_KEY_HAN
   TPM_SESSION_DATA *session;
   TPM_STORE_ASYMKEY store;
   rsa_private_key_t rsa;
-  UINT32 key_length;
+  size_t key_length;
 
   info("TPM_CreateWrapKey()");
   /* get parent key */
@@ -428,11 +443,11 @@ TPM_RESULT TPM_CreateWrapKey(TPM_KEY_HAN
   }
   if (compute_key_digest(wrappedKey, &store.pubDataDigest)) return TPM_FAIL;
   /* generate key and store it */
-  key_length = keyInfo->algorithmParms.parms.rsa.keyLength;
-  if (rsa_generate_key(&rsa, key_length)) return TPM_FAIL;
-  wrappedKey->pubKey.keyLength = key_length >> 3;
+  if (rsa_generate_key(&rsa, keyInfo->algorithmParms.parms.rsa.keyLength)) 
+    return TPM_FAIL;
+  wrappedKey->pubKey.keyLength = keyInfo->algorithmParms.parms.rsa.keyLength >> 3;
   wrappedKey->pubKey.key = tpm_malloc(wrappedKey->pubKey.keyLength);
-  store.privKey.keyLength = key_length >> 4;
+  store.privKey.keyLength = keyInfo->algorithmParms.parms.rsa.keyLength >> 4;
   store.privKey.key = tpm_malloc(store.privKey.keyLength);
   wrappedKey->encDataSize = parent->key.size >> 3;
   wrappedKey->encData = tpm_malloc(wrappedKey->encDataSize);
@@ -444,9 +459,11 @@ TPM_RESULT TPM_CreateWrapKey(TPM_KEY_HAN
     tpm_free(wrappedKey->encData);
     return TPM_FAIL;
   }
-  rsa_export_modulus(&rsa, wrappedKey->pubKey.key, 
-    &wrappedKey->pubKey.keyLength);
-  rsa_export_prime1(&rsa, store.privKey.key, &store.privKey.keyLength);
+  rsa_export_modulus(&rsa, wrappedKey->pubKey.key,
+		     &key_length);
+  wrappedKey->pubKey.keyLength = (UINT32) key_length;
+  rsa_export_prime1(&rsa, store.privKey.key, &key_length);
+  store.privKey.keyLength = (UINT32) key_length;
   rsa_release_private_key(&rsa);
   /* encrypt private key data */
   if (encrypt_private_key(parent, &store, wrappedKey->encData, 
@@ -567,6 +584,7 @@ TPM_RESULT TPM_LoadKey2(TPM_KEY_HANDLE p
 
 int tpm_setup_key_parms(TPM_KEY_DATA *key, TPM_KEY_PARMS *parms)
 {
+  size_t key_length;
   parms->algorithmID = TPM_ALG_RSA;
   parms->encScheme = key->encScheme;
   parms->sigScheme = key->sigScheme;
@@ -576,7 +594,8 @@ int tpm_setup_key_parms(TPM_KEY_DATA *ke
   parms->parms.rsa.exponent = tpm_malloc(parms->parms.rsa.exponentSize);
   if (parms->parms.rsa.exponent == NULL) return -1;
   rsa_export_exponent(&key->key, parms->parms.rsa.exponent,
-    &parms->parms.rsa.exponentSize);
+    &key_length);
+  parms->parms.rsa.exponentSize = (UINT32) key_length;
   parms->parmSize = 12 + parms->parms.rsa.exponentSize;
   return 0;
 }
@@ -587,6 +606,7 @@ TPM_RESULT TPM_GetPubKey(TPM_KEY_HANDLE 
   TPM_RESULT res;
   TPM_KEY_DATA *key;
   TPM_DIGEST digest;
+  size_t key_length;
   info("TPM_GetPubKey()");
   /* get key */
   if (keyHandle == TPM_KH_SRK) return TPM_BAD_PARAMETER;
@@ -614,8 +634,8 @@ TPM_RESULT TPM_GetPubKey(TPM_KEY_HANDLE 
   pubKey->pubKey.keyLength = key->key.size >> 3;
   pubKey->pubKey.key = tpm_malloc(pubKey->pubKey.keyLength);
   if (pubKey->pubKey.key == NULL) return TPM_FAIL;
-  rsa_export_modulus(&key->key, pubKey->pubKey.key, 
-    &pubKey->pubKey.keyLength);
+  rsa_export_modulus(&key->key, pubKey->pubKey.key, &key_length); 
+  pubKey->pubKey.keyLength = (UINT32) key_length;
   if (tpm_setup_key_parms(key, &pubKey->algorithmParms) != 0) {
     tpm_free(pubKey->pubKey.key);
     return TPM_FAIL;
